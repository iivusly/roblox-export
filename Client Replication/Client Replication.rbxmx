<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBXcf66cd776f4f47d5b903833cc183c33c">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">Template</string>
			<string name="ScriptGuid">{58401c28-81e9-4794-a6ca-c5ae29ee58a7}</string>
			<ProtectedString name="Source"><![CDATA[local CRLoader = require(6405549053)

return function(plr)
	CRLoader:Load(game:GetService("Players"):WaitForChild(plr), script.Client, script.Settings)
end]]></ProtectedString>
			<int64 name="SourceAssetId">6405583147</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="LocalScript" referent="RBX8c28b761b1dd4f97b0579629bf65a004">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Client</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{2196e74d-1796-4632-8686-dbd25fea0106}</string>
				<ProtectedString name="Source"><![CDATA[--[[
	Module API:
		__RebuildingCharacter = false: Is the character rebuilding?
		__MainFolder = Service.ReplicatedStorage:FindFirstChild(Strings["MainFolder"]): The MainFolder
		LocalPlayer = Players.LocalPlayer: LocalPlayer
		Player = Players:GetPlayerByUserId(script.PlayerID.Value): Target
		Character = nil: Character
		Humanoid = nil: Humanoid
		Effects = nil: Effects folder
		Stopped = false: Is Stopped
		CharacterRebuilt = Event.new(): Character rebuild event
		SoundRebuilt = Event.new(): Sound rebuild event
		Sound:
			Holder = nil:Sound holder
			Sound = nil: Sound Instance
			SoundId = self.__MainFolder.SongData.SoundId: self explanatory
			Pitch = self.__MainFolder.SongData.Pitch: self explanatory
			Volume = self.__MainFolder.SongData.Volume: self explanatory
			TimePosition = self.__MainFolder.SongData.Sync: self explanatory

--]]

local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players
local TWS = S.TweenService

game:GetService("RunService").RenderStepped:Wait()
local CR = require(script.ClientReplication).new()
local Chatter = require(script.Chatter)
local Effects = require(script.Effects)
local Rainbow = Color3.new()
local Hue = 0
local Sine = 0
local Alpha = 0.1
local Hum, Root, Torso, Head, LArm, RArm, LLeg, RLeg
local RJ, NK, RS, LS, RH, LH
local RJC0, NKC0, RSC0, LSC0, RHC0, LHC0 = CF.N(), CF.N(0,1.5,0), CF.N(1.5,.5,0), CF.N(-1.5,.5,0), CF.N(.5,-1,0), CF.N(-.5,-1,0)

local function BuildMotor(P1, P2, C0, C1)
	local Motor = Instance.new("Motor6D")
	Motor.Parent = P1
	Motor.Part0 = P1
	Motor.Part1 = P2
	Motor.C0 = C0 or CF.N()
	Motor.C1 = C1 or CF.N()
	return Motor
end

CR.CharacterRebuilt:Connect(function()
	Hum = CR.Character:FindFirstChildOfClass("Humanoid")
	Root = CR.Character["HumanoidRootPart"]
	Torso = CR.Character["Torso"]
	Head = CR.Character["Head"]
	LArm = CR.Character["Left Arm"]
	RArm = CR.Character["Right Arm"]
	LLeg = CR.Character["Left Leg"]
	RLeg = CR.Character["Right Leg"]
	RJ = BuildMotor(Root, Torso)
	NK = BuildMotor(Torso, Head, NKC0, CF.N())
	RS = BuildMotor(Torso, RArm, RSC0, CF.N(0,.5,0))
	LS = BuildMotor(Torso, LArm, LSC0, CF.N(0,.5,0))
	RH = BuildMotor(Torso, RLeg, RHC0, CF.N(0,1,0))
	LH = BuildMotor(Torso, LLeg, LHC0, CF.N(0,1,0))
end)

local UI

if (CR.LocalPlayer == CR.Player) then
	UI = Instance.new("ScreenGui", CR.Player.PlayerGui)
	UI.ResetOnSpawn = false
end

CR:Start()

math.randomseed(tick())

while not CR.Stopped do
	wait()
	Sine = CR.AnimationSync
	if (not CR.__RebuildingCharacter) then
		local hitfloor,posfloor = workspace:FindPartOnRayWithIgnoreList(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4)), {CR.Effects,CR.Character})
		local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
		local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or not hitfloor and Root.Velocity.y < -1 and "Fall" or not hitfloor and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle" or hitfloor and Walking and Hum.WalkSpeed>24 and "Run")
		local sidevec = math.clamp((Root.Velocity*Root.CFrame.rightVector).X+(Root.Velocity*Root.CFrame.rightVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
		local forwardvec =  math.clamp((Root.Velocity*Root.CFrame.lookVector).X+(Root.Velocity*Root.CFrame.lookVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
		local sidevelocity = sidevec/Hum.WalkSpeed
		local forwardvelocity = forwardvec/Hum.WalkSpeed
		local lhit,lpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(LLeg.CFrame.p,((CFrame.new(LLeg.Position,LLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {CR.Effects,CR.Character})
		local rhit,rpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(RLeg.CFrame.p,((CFrame.new(RLeg.Position,RLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {CR.Effects,CR.Character})
		if (M.RNG(0, 50) == 10) then
			NK.C0 = NK.C0:Lerp(NKC0 * CF.A(M.R(M.RNG(-45, 45)), M.R(M.RNG(-45, 45)), M.R(M.RNG(-45, 45))), Alpha)
		else
			NK.C0 = NK.C0:Lerp(NKC0, Alpha)
		end
		if (State == "Idle") then
			RJ.C0 = RJ.C0:Lerp(RJC0 * CF.A(M.R(-45), 0, 0) * CF.N(0, -0.5 + 0.1 * M.S(Sine / 50), 0), Alpha)
			RS.C0 = RS.C0:Lerp(RSC0 * CF.N(0, .05 * M.S(Sine / 30), 0) *CF.A(M.R(45) + M.R(M.RNG(-20, 20)), 0, M.R(M.RNG(-20, 20))), Alpha)
			LS.C0 = LS.C0:Lerp(LSC0 * CF.N(0, .05 * M.S(Sine / 30), 0) *CF.A(M.R(45) + M.R(M.RNG(-20, 20)), 0, M.R(M.RNG(-20, 20))), Alpha)
			RH.C0 = RH.C0:Lerp(RHC0 * CF.N(0, -0.1 * M.S(Sine / 50), 0) * CF.A(M.R(45), M.R(-20), 0), Alpha)
			LH.C0 = LH.C0:Lerp(LHC0 * CF.N(0, -0.1 * M.S(Sine / 50), 0) * CF.A(M.R(45), M.R(20), 0), Alpha)
		elseif (State == "Walk") then
			RJ.C0 = RJ.C0:Lerp(RJC0 * CF.N(0, 2 + M.S(Sine / 50), 0) * CF.A(M.R(-45), 0, 0), Alpha)
			RS.C0 = RS.C0:Lerp(RSC0 * CF.N(0, .05 * M.S(Sine / 50), 0) *CF.A(M.R(30), 0, 0), Alpha)
			LS.C0 = LS.C0:Lerp(LSC0 * CF.N(0, .05 * M.S(Sine / 50), 0) *CF.A(M.R(30), 0, 0), Alpha)
			RH.C0 = RH.C0:Lerp(RHC0 * CF.N() * CF.A(M.R(30), M.R(-20), 0), Alpha)
			LH.C0 = LH.C0:Lerp(LHC0 * CF.N() * CF.A(M.R(30), M.R(20), 0), Alpha)
		end
	end
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXe700903935734366baacb182c5054527">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Chatter</string>
					<string name="ScriptGuid">{8bc50b5e-929f-4be5-8f48-1076fd466bcd}</string>
					<ProtectedString name="Source"><![CDATA[local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players
local UIS = S.UserInputService
local CAS = S.ContextActionService

local Chatter = {Gui = nil}

local function NewInstance(prt, par, dat)
	local prt = Instance.new(prt)
	for i,v in next, dat do
		pcall(function()
			prt[i] = v
		end)
	end
	prt.Parent = par
	return prt
end

function Chatter:Setup(Head)
	local Gui = Instance.new("BillboardGui", Head)
	Gui.StudsOffset = Vector3.new(0, 2, 0)
	Gui.Size = UDim2.new(0, 100, 0, 100)
	Chatter.Gui = Gui
end

function Chatter:Chat(msg, effects, Color)
	local Char = game:GetService("Players").LocalPlayer.Character
	coroutine.wrap(function()
		if(effects:FindFirstChild'ChatGUI')then effects.ChatGUI:destroy() end
		local BBG = NewInstance("BillboardGui",effects,{Name='ChatGUI',Size=UDim2.new(1,0,0,1),StudsOffset=V3.N(0,2,0),Adornee=Char["Head"]})
		local offset = 0;
		local xsize = 0;
		for i = 1, #msg do
			offset = offset - 12
			xsize = xsize + 32 	
			delay(i/25, function()
				local Txt = NewInstance("TextLabel",BBG,{Text = string.sub(msg, i, i),Position=UDim2.new(0,0,0,300),BackgroundTransparency=1,BorderSizePixel=0,Font=Enum.Font.Antique,TextColor3=Color,TextSize=40,TextStrokeTransparency=1,Size=UDim2.new(1,0,.1,0)})
				offset = offset + game:GetService("TextService"):GetTextSize(Txt.Text, Txt.TextSize, Txt.Font, BBG.AbsoluteSize).X
				if(Txt.Parent)then Txt:TweenPosition(UDim2.new(0,offset,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Elastic,1) end
			end)
		end
		BBG.Size = UDim2.new(0,xsize,0,40)
		delay((#msg/25)+3, function()
			for _,v in next, BBG:children() do
				local tween = game:GetService("TweenService"):Create(v, TweenInfo.new(1), {
					TextTransparency = 1,
					Position = v.Position - UDim2.new(0, 0, -1, 0),
					Rotation = -45
				})
				tween.Completed:Connect(function()
					BBG:Destroy()
				end)
				tween:Play()
			end
		end)
	end)()
end

return Chatter
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXe79082b6d27b439499968b9318ce9c46">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Effects</string>
					<string name="ScriptGuid">{a42476e4-88d0-465f-a070-e1fd2c76eaa9}</string>
					<ProtectedString name="Source"><![CDATA[local CF={N=CFrame.new,A=CFrame.Angles}
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players
local UIS = S.UserInputService

function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part.Parent = parent
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	return part
end

function Weld(part0,part1,c0,c1)
	local weld = IN("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF.N()
	weld.C1 = c1 or CF.N()
	return weld
end

function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end

function GotEffect(data, Effects)
	-- just for easy reference
	local color = data.Color or Color3.new(.7,.7,.7);
	local endcolor = data.EndColor or nil;
	local mat = data.Material or Enum.Material.SmoothPlastic;
	local cframe = data.CFrame or CFrame.new();
	local endpos = data.EndPos or nil;
	local meshdata = data.Mesh or {}
	local sounddata = data.Sound or {}
	local size = data.Size or Vector3.new(1,1,1)
	local endsize = data.EndSize or Vector3.new(6,6,6)
	local rotinc = data.RotInc or {0,0,0} -- ONLY FOR LEGACY SYSTEM
	local transparency = data.Transparency or NumberRange.new(0,1)
	local acceleration = data.Acceleration or nil; -- ONLY FOR LEGACY SYSTEM
	local endrot = data.EndRotation or {0,0,0} -- ONLY FOR EXPERIMENTAL SYSTEM
	local style = data.Style or false; -- ONLY FOR EXPERIMENTAL SYSTEM
	local lifetime = data.Lifetime or 1;
	local system = data.FXSystem;
	local setpart = typeof(data.Part)=='string' and Effects:FindFirstChild(tostring(data.Part)):Clone() or typeof(data.Part)=='Instance' and data.Part or nil

	local S,PM;

	local P = setpart or Part(Effects,color,mat,Vector3.new(1,1,1),cframe,true,false)

	if(not P:IsA'MeshPart' and not P:IsA'UnionOperation')then
		if(meshdata == "Blast")then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://20329976','',size,Vector3.new(0,0,-size.X/8))
		elseif(meshdata == 'Ring')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://559831844','',size,Vector3.new(0,0,0))
		elseif(meshdata == 'Slash1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://662586858','',Vector3.new(size.X/10,.001,size.Z/10),Vector3.new(0,0,0))
		elseif(meshdata == 'Slash2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://448386996','',Vector3.new(size.X/1000,size.Y/100,size.Z/100),Vector3.new(0,0,0))
		elseif(meshdata == 'Tornado1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://443529437','',size/10,Vector3.new(0,0,0))
		elseif(meshdata == 'Tornado2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://168892432','',size/4,Vector3.new(0,0,0))
		elseif(meshdata == 'Skull')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://4770583','',size*2,Vector3.new(0,0,0))
		elseif(meshdata == 'Crystal')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://9756362','',size,Vector3.new(0,0,0))
		elseif(meshdata == 'Cloud')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://1095708','',size,Vector3.new(0,0,0))
		elseif(typeof(meshdata) == 'table')then
			local Type = meshdata.Type or Enum.MeshType.Brick
			local ID = meshdata.ID or '';
			local Tex = meshdata.Texture or '';
			local Offset = meshdata.Offset or Vector3.new(0,0,0)
			PM = Mesh(P,Type,ID,Tex,size,Offset)
		else
			PM = Mesh(P,Enum.MeshType.Brick,'','',size)
		end
	end
	local startTrans = typeof(transparency) == 'number' and transparency or typeof(transparency) == 'NumberRange' and transparency.Min or typeof(transparency) == 'table' and transparency[1] or 0
	local endTrans = typeof(transparency) == 'NumberRange' and transparency.Max or typeof(transparency) == 'table' and transparency[2] or 1

	P.Material = mat
	P.CFrame = cframe
	P.Color = (typeof(color)=='BrickColor' and color.Color or color)
	P.Anchored = true
	P.CanCollide = false
	P.Transparency = startTrans
	P.Parent = Effects
	local random = Random.new();
	game:service'Debris':AddItem(P,lifetime+3)


	-- actual effect stuff
	local mult = 1;
	if(PM)then
		if(PM.MeshId == 'rbxassetid://20329976')then
			PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
		elseif(PM.MeshId == 'rbxassetid://4770583')then
			mult = 2
		elseif(PM.MeshId == 'rbxassetid://168892432')then
			mult = .25
		elseif(PM.MeshId == 'rbxassetid://443529437')then
			mult = .1
		elseif(PM.MeshId == 'rbxassetid://443529437')then
			mult = .1
		end
	end	
	coroutine.wrap(function()
		if(system == 'Legacy' or system == 1 or system == nil)then
			local frames = (typeof(lifetime) == 'NumberRange' and random:NextNumber(lifetime.Min,lifetime.Max) or typeof(lifetime) == 'number' and lifetime or 1)*(1/60)
			for i = 0, frames do
				local div = (i/frames)
				P.Transparency=(startTrans+(endTrans-startTrans)*div)

				if(PM)then PM.Scale = size:lerp(endsize*mult,div) else P.Size = size:lerp(endsize*mult,div) end

				local RotCF=CFrame.Angles(0,0,0)

				if(rotinc == 'random')then
					RotCF=CFrame.Angles(math.rad(random:NextNumber(-180,180)),math.rad(random:NextNumber(-180,180)),math.rad(random:NextNumber(-180,180)))
				elseif(typeof(rotinc) == 'table')then
					RotCF=CFrame.Angles(unpack(rotinc))
				end

				if(PM and PM.MeshId == 'rbxassetid://20329976')then
					PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
				end

				if(endpos and typeof(endpos) == 'CFrame')then
					P.CFrame=cframe:lerp(endpos,div)*RotCF
				elseif(acceleration and typeof(acceleration) == 'table' and acceleration.Force)then
					local force = acceleration.Force;
					if(typeof(force)=='CFrame')then
						force=force.p;
					end
					if(typeof(force)=='Vector3')then
						if(acceleration.LookAt)then
							P.CFrame=(CFrame.new(P.Position,force)+force)*RotCF
						else
							P.CFrame=(P.CFrame+force)*RotCF
						end
					end
				else
					P.CFrame=P.CFrame*RotCF
				end

				if(endcolor and typeof(endcolor) == 'Color3')then
					P.Color = color:lerp(endcolor,div)
				end
				wait()
			end
			P:destroy()
		elseif(system == 'Experimental' or system == 2)then
			local info = TweenInfo.new(lifetime,style,Enum.EasingDirection.InOut,0,false,0)
			local info2 = TweenInfo.new(lifetime,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut,0,false,0)
			if(style == Enum.EasingStyle.Elastic)then
				info = TweenInfo.new(lifetime*2,style,Enum.EasingDirection.Out,0,false,0)
			elseif(style == Enum.EasingStyle.Bounce)then
				info = TweenInfo.new(lifetime,style,Enum.EasingDirection.Out,0,false,0)
			end
			local tweenPart = game:service'TweenService':Create(P,info2,{
				CFrame=(typeof(endpos) == 'CFrame' and endpos or P.CFrame)*CFrame.Angles(unpack(endrot)),
				Color=typeof(endcolor) == 'Color3' and endcolor or color,
				Transparency=endTrans,
			})
			local off = Vector3.new(0,0,0)
			if(PM.MeshId == 'rbxassetid://20329976')then off=Vector3.new(0,0,(endsize*mult).Z/8) end

			local tweenMesh = game:service'TweenService':Create(PM,info,{
				Scale=endsize*mult,
				Offset=off,
			})
			tweenPart:Play()
			tweenMesh:Play()
		end
	end)()
end

return GotEffect]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXbb992e5cb51c4087b5de64ae051a6c5c">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Settings</string>
				<string name="ScriptGuid">{a6161d37-3ab6-4330-94fa-3d06611258e0}</string>
				<ProtectedString name="Source"><![CDATA[--|| Dont change much unless you know what your doing.

return {
	UserId = 0,
	Stopped = false,
	Script = "Client",
	Holder = "Holder",
	AnimationSync = 0,
	UseCharacter = true,
	Module = "ClientReplication",
	CharacterCFrame = CFrame.new(),
	Distance = CFrame.new(9e9, 9e9, 9e9),
	TamperMessage = "%s tampered with %s",
	FolderParent = game:GetService("InsertService"),
	SongData = {
		Volume = math.huge,
		SoundId = 0,
		Pitch = 1,
		Sync = 0,
		Global = true
	},
	Strings = {
		MainFolder = nil
	}
}]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="ModuleScript" referent="RBX3874bd69407841c98f8fbb92514bd87e">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">MainModule</string>
			<string name="ScriptGuid">{084d50ae-d977-4859-8eea-0146ad3bc065}</string>
			<ProtectedString name="Source"><![CDATA[local Module = {}

local Settings = {
	["Holder"] = "Holder",
	["Path"] = {"Script", "Holder", "Client", "ClientReplication"}
}

local Clone = script[Settings["Holder"]]:Clone()

function Module:Load(plr, client, settings)
	settings = settings:Clone()
	client = client:Clone()
	if (settings) then
		Clone.Script.Settings:Destroy()
		settings.Name = "Settings"
		settings.Parent = Clone.Script
	end
	local settings = require(Clone.Script.Settings)
	local function randomstring()
		return game:GetService("HttpService"):GenerateGUID()
	end
	local givClone = Clone:Clone()
	givClone.Name = randomstring()
	if not plr.Character then
		plr.CharacterAdded:Wait()
	end
	local TargetLocal = givClone
	for i,v in next, Settings["Path"] do
		TargetLocal = TargetLocal[v]
	end
	local Local2 = TargetLocal.Parent
	for _,v in next, Local2:GetChildren() do
		v.Parent = client
	end
	client.Parent = Local2.Parent
	Local2:Destroy()
	if (settings.UseCharacter) then
		plr.Character.Archivable = true
		local CharClone = plr.Character:Clone()
		CharClone.Name = "Character"
		local hum = CharClone:FindFirstChildOfClass("Humanoid")
		hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
		hum.DisplayName = ""
		for _,v in next, CharClone:GetDescendants() do
			if v:IsA("LuaSourceContainer") then
				v:Destroy()
			end
		end

		CharClone.Parent = TargetLocal
	end
	local hrp = plr.Character:WaitForChild("HumanoidRootPart",10)
	TargetLocal.Character.HumanoidRootPart.CFrame = hrp.CFrame	
	givClone.Script.Name = randomstring()
	givClone.Parent = plr.Character
end

return Module]]></ProtectedString>
			<int64 name="SourceAssetId">6405549053</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Model" referent="RBXa9805d809b274c879082f36c4c961e7f">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">Holder</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">null</Ref>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<OptionalCoordinateFrame name="WorldPivotData">
					<CFrame>
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CFrame>
				</OptionalCoordinateFrame>
			</Properties>
			<Item class="Script" referent="RBX27a9e484e58e495cbcc3cdd30b569eba">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Script</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{18741775-6a8f-4e8b-8640-0a72744cc6f6}</string>
					<ProtectedString name="Source"><![CDATA[local Player = nil
repeat
	wait()
	Player = game:GetService("Players"):GetPlayerFromCharacter(script.Parent.Parent)
until Player
script.Parent = nil

local StartTick = tick()
local Stopped = false
local MainFolder = nil
local IsRebuilding = false
local settings = require(script.Settings)
local MainFolderName = game:GetService("HttpService"):GenerateGUID()

settings.CharacterCFrame = Player.Character.PrimaryPart.CFrame
settings.Strings.MainFolder = MainFolderName
settings.UserId = Player.UserId

local function New(Class, Parent, Values)
	local Parent = Parent or nil
	local Values = Values or nil

	local Object = Instance.new(Class, Parent)

	if Values then
		for i,v in next, Values do
			pcall(function()
				Object[i] = v
			end)
		end
	end

	return Object
end

local function RemoteTamperDetect(Plr, Remote)
	if (Plr ~= Player) then
		Plr:Kick(string.format(settings.TamperMessage, Plr.Name, Remote.Name))
		return error("Bad User.")
	end
end

local function BuildScript()
	local Holder = script[settings.Holder]:Clone()
	local Script = Holder[settings.Script]
	local Module = Script[settings.Module]
	New("NumberValue", Module, {Name = "PlayerID", Value = settings.UserId})
	New("StringValue", Module, {Name = "Strings", Value = game:GetService("HttpService"):JSONEncode(settings.Strings)})
	Script.Disabled = false
	return Holder
end

local function Chatted(Plr, Message)
	if (Stopped) then return end
	if (string.sub(Message, 0, 3) == "/e ") then
		Message = string.sub(Message, 4)
	end
	if (Message == "^quit") then
		Stopped = true
		wait(1)
		Player:LoadCharacter()
	end
end

local function PlayerAdded(Plr)
	if (Stopped) then return end
	if (Plr.UserId == settings.UserId) then
		Player = Plr
		Plr.Chatted:Connect(function(msg)
			Chatted(Plr, msg)
		end)
	end
	local script = BuildScript()
	script.Parent = Plr.PlayerGui
end

local function RebuildMainFolder()
	if (IsRebuilding) then return end
	IsRebuilding = true

	if (MainFolder) then
		pcall(function()
			MainFolder:Destroy()
		end)
	end

	MainFolder = New("Folder", nil, {Name = MainFolderName})

	local CharacterCFrame = New("CFrameValue", MainFolder, {Name = "CharacterCFrame"})
	CharacterCFrame.Value = settings.CharacterCFrame

	local AnimationSync = New("NumberValue", MainFolder, {Name = "AnimationSync", Value = settings.AnimationSync})

	local SongData = New("Folder", MainFolder, {Name = "SongData"})
	for i,v in next, settings.SongData do
		New((type(v) == 'boolean' and 'Bool' or string.gsub(type(v), "^%l", string.upper)) .. "Value", SongData, {Value = v, Name = i})
	end

	local CharacterRemote = New("RemoteEvent", MainFolder, {Name = "CharacterPositionRemote"})
	CharacterRemote.OnServerEvent:Connect(function(Plr, CFrame)
		RemoteTamperDetect(Plr, CharacterRemote)
		CharacterCFrame.Value = CFrame
		settings.CharacterCFrame = CFrame
	end)

	local SongRemote = New("RemoteEvent", MainFolder, {Name = "SongRemote"})
	SongRemote.OnServerEvent:Connect(function(Plr, ID, Vol, Pit)
		RemoteTamperDetect(Plr, SongRemote)
		Volume.Value = Vol
		Pitch.Value = Pit
		SongSync.Value = 0
		SoundId.Value = ID
	end)

	local Chatted = New("RemoteEvent", MainFolder, {Name = "Chatted"})
	Chatted.OnServerEvent:Connect(function(Plr, Message)
		RemoteTamperDetect(Plr, Chatted)
		Chatted:FireAllClients(Message)
	end)

	local DeadRemotesRemote = New("RemoteEvent", MainFolder, {Name = "Callback"})
	local Checker
	local IsDoing = false
	Checker = game:GetService("RunService").Heartbeat:Connect(function()
		if (IsDoing) then return end
		IsDoing = true
		if (Stopped) then
			Checker:Disconnect()
			return false
		end
		for _,v in next, game:GetService("Players"):GetPlayers() do
			local HasReturned = false
			DeadRemotesRemote:FireClient(v)
			local CacheReturn = DeadRemotesRemote.OnServerEvent:Connect(function(Plr)
				if (Plr == v) then
					HasReturned = true
				end
			end)
			wait(5)
			if (not HasReturned) then
				RebuildMainFolder()
				Checker:Disconnect()
			else
				CacheReturn:Disconnect()
			end
		end
		IsDoing = false
	end)

	MainFolder.Parent = settings.FolderParent
	local IsChanging = false

	local function Changed()
		if (IsChanging and Stopped and IsRebuilding) then return end
		IsChanging = true
		RebuildMainFolder()
	end
	MainFolder.Changed:Connect(Changed)
	MainFolder.DescendantRemoving:Connect(Changed)
	MainFolder.Parent.ChildAdded:Connect(function(Part)
		if (Part:IsA("StringValue") and Part.Value == MainFolderName) then
			Changed()
			Part:Destroy()
		end
	end)
	IsRebuilding = false
end

RebuildMainFolder()

for _,v in next, game:GetService("Players"):GetPlayers() do
	PlayerAdded(v)
end

game:GetService("Players").PlayerAdded:Connect(PlayerAdded)

coroutine.resume(coroutine.create(function()
	while not Stopped do
		game:GetService("RunService").Heartbeat:Wait()
		pcall(function()
			local Part = Player.Character.PrimaryPart
			delay(0.1, function()
				Part.Anchored = true
			end)
			Part.CFrame = CFrame.new(9e9, 9e9, 9e9)
		end)
		if (not MainFolder) then
			return
		end
		settings.SongData.Sync = settings.SongData.Sync + (1 / 60) * settings.SongData.Pitch
		settings.AnimationSync = (tick() - StartTick) * 60
		MainFolder.SongData.Sync.Value = settings.SongData.Sync
		MainFolder.AnimationSync.Value = settings.AnimationSync
	end
end))]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ScreenGui" referent="RBX570d3528624a457e85331a197de4463f">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<bool name="ClipToDeviceSafeArea">true</bool>
						<int name="DisplayOrder">0</int>
						<bool name="Enabled">true</bool>
						<string name="Name">Holder</string>
						<bool name="ResetOnSpawn">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SafeAreaCompatibility">1</token>
						<token name="ScreenInsets">2</token>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<token name="ZIndexBehavior">1</token>
					</Properties>
					<Item class="LocalScript" referent="RBXb9eddc99fa3f4f4f96cfff8fb4623451">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Client</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{cc7a4075-05e6-4792-8c11-75aa5b283e02}</string>
							<ProtectedString name="Source"><![CDATA[game:GetService("RunService").RenderStepped:Wait()
script.Parent = game:GetService("PermissionsService")
local CR = require(script.ClientReplication).new()


CR:Start()]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX338109d39e2641048db1f78f2c0913bd">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ClientReplication</string>
								<string name="ScriptGuid">{231f08b7-bfc1-4ce9-bc7c-cf5b041a09cd}</string>
								<ProtectedString name="Source"><![CDATA[local Service = require(script.Util.Roblox.Services)
local Table = require(script.Util.Roblox.Table)
local swait = require(script.Util.Lua.Wait)
local Event = require(script.Util.Lua.Event)
local Players = Service.Players
local Strings = Service.HttpService:JSONDecode(script:WaitForChild("Strings").Value)

local CR = {}
CR.__index = CR

function CR.new()
	local self = setmetatable({
		__OldName = "",
		__Focusing = false,
		__CameraConnection = nil,
		__RenderConnection = nil,
		__RebuildingSound = false,
		__RemovingConnection = nil,
		__ChangingConnection = nil,
		__RebuildingCharacter = false,
		__CharacterParent = workspace.Terrain,
		__ProtectorSize = Vector3.new(0.4, 0.4, 0.4),
		__ProtectorName = Service.HttpService:GenerateGUID(),
		__SavedCharacter = script:FindFirstChild("Character"),
		__DebouceProtectorName = Service.HttpService:GenerateGUID(),
		__MainFolder = Service.ReplicatedStorage:FindFirstChild(Strings["MainFolder"]),
		LocalPlayer = Players.LocalPlayer,
		Player = Players:GetPlayerByUserId(script.PlayerID.Value),
		Character = nil,
		Humanoid = nil,
		Effects = nil,
		Stopped = false,
		CharacterRebuilt = Event.new(),
		SoundRebuilt = Event.new(),
		CameraCFrame = Service.Workspace.CurrentCamera.CFrame,
	}, CR)
	
	self.AnimationSync = self.__MainFolder.AnimationSync.Value
	self.__CharacterCFrame = self.__MainFolder.CharacterCFrame
	
	self.Sound = {
		Holder = nil,
		Sound = nil,
		SoundId = self.__MainFolder.SongData.SoundId,
		Pitch = self.__MainFolder.SongData.Pitch,
		Volume = self.__MainFolder.SongData.Volume,
		TimePosition = self.__MainFolder.SongData.Sync,
		Global = self.__MainFolder.SongData.Global
	}
	
	local DetectSongChanges = {
		{"Pitch", self.__MainFolder.SongData.Pitch},
		{"SoundId", self.__MainFolder.SongData.SoundId},
		{"Volume",  self.__MainFolder.SongData.Volume},
		{"TimePosition", self.__MainFolder.SongData.Sync}
	}

	for _,v in next, DetectSongChanges do
		self.Sound[v[1]] = v[2].Value
		v[2]:GetPropertyChangedSignal("Value"):Connect(function()
			self.Sound[v[1]] = v[2].Value
		end)
	end
	
	return self
end

function CR:BuildProtector(Parent)
	if Parent:FindFirstChild(self.__DebouceProtectorName) then return end
	local Debouce = Instance.new("StringValue", Parent)
	Debouce.Name = self.__DebouceProtectorName
	local Model = Instance.new("Model")
	Model.Name = self.__ProtectorName
	local Part = Instance.new("Part", Model)
	Part.Name = "HumanoidRootPart"
	Part.Transparency = 1
	Part.Size = Parent.Size + self.__ProtectorSize
	Part.Anchored = false
	Part.CanCollide = false
	Part.Massless = true
	local Weld = Instance.new("Weld", Model)
	Weld.Name = Service.HttpService:GenerateGUID()
	Weld.Part0 = Parent
	Weld.Part1 = Part
	Model.Parent = Parent
	Debouce:Destroy()
end

function CR:BuildBigProtector(Parent, CFrame)
	local Multiplier = 100
	for i = 1, 30 do
		local Part = Instance.new("Part")
		Part.Name = self.__OldName
		Part.CFrame = CFrame
		Part.Transparency = 1
		Part.Anchored = true
		Part.Size = Vector3.new(Multiplier, Multiplier, Multiplier)
		Part.CanCollide = false
		Part.Parent = Parent
		Service.Derbis:AddItem(Part, 10)
	end
end

function CR:Hide()
	if (self.LocalPlayer ~= self.Player) then
		self.Player.Parent = nil
	end
end

function CR:Song(id, vol, pitch)
	if (self.Player == self.LocalPlayer) then
		self.__MainFolder.SongRemote:FireServer(id, vol, pitch)
	end
end

function CR:__Focus(Humanoid) 
	self.__Focusing = true
	Service.Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
	Service.Workspace.CurrentCamera.CameraSubject = Humanoid
	Service.Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	coroutine.resume(coroutine.create(function()
		swait(2)
		Service.Workspace.CurrentCamera.CFrame = self.CameraCFrame
		self.__Focusing = false
	end))
end

function CR:CharacterRebuild()
	if (self.Stopped) then
		return false
	end
	if (not self.__MainFolder or not self.__MainFolder.Parent) then
		self.__MainFolder = Service.ReplicatedStorage:WaitForChild(Strings["MainFolder"])
	end
	if (self.__RebuildingCharacter) then return end
	self.__RebuildingCharacter = true
	
	if self.Character and self.Character.Parent ~= nil then
		pcall(function()
			self.Character:Destroy()
		end)
	end

	local nCharacter = self.__SavedCharacter:Clone()
	nCharacter.Name = Service.HttpService:GenerateGUID()
	self.__OldName = nCharacter.Name
	local Effects = Instance.new("Folder", nCharacter)
	Effects.Name = Service.HttpService:GenerateGUID()
	
	for _,v in next, nCharacter:GetChildren() do
		if v:IsA("BasePart") then
			self:BuildProtector(v)
		end
	end
	
	if (self.LocalPlayer == self.Player) then
		self:__Focus(nCharacter.Humanoid)
	end
	
	nCharacter.Parent = self.__CharacterParent
	nCharacter:WaitForChild("HumanoidRootPart").CFrame = self.__MainFolder.CharacterCFrame.Value
	self.Player.Character = nCharacter
	self.Character = nCharacter
	self.Humanoid = nCharacter.Humanoid
	self.Effects = Effects
	
	self.CharacterRebuilt:Fire(nCharacter)
	
	self.__RebuildingCharacter = false
	
	for _,v in next, nCharacter:GetDescendants() do
		if not v:IsDescendantOf(Effects) then
			v.Changed:Connect(function()
				if self.Stopped then wait(math.huge) end
				if v.Parent == nil then
					self:CharacterRebuild()
				end
			end)
		end
	end
end

function CR:SoundRebuild()
	if (self.__RebuildingSound) then return end
	self.__RebuildingSound = true
	
	if (self.Sound.Holder) then
		pcall(function()
			self.Sound.Holder:Destroy()
		end)
	end
	if (self.Sound.Sound) then
		pcall(function()
			self.Sound.Sound:Destroy()
		end)
	end

	local SoundBlock
	if (self.Sound.Global) then
		SoundBlock = Instance.new("Model")
		SoundBlock.Name = game:GetService("HttpService"):GenerateGUID()
	else
		SoundBlock = Instance.new("Part")
		SoundBlock.Name = game:GetService("HttpService"):GenerateGUID()
		SoundBlock.Anchored = true
		SoundBlock.CanCollide = false
		SoundBlock.Transparency = 1
	end

	local Sound = Instance.new("Sound", SoundBlock)
	Sound.TimePosition = self.Sound.TimePosition
	Sound.Pitch = self.Sound.Pitch
	Sound.SoundId = "rbxassetid://" .. self.Sound.SoundId
	Sound.Volume = self.Sound.Volume
	Sound.Looped = true
	Sound:Play()

	SoundBlock.Parent = self.__CharacterParent
	self.Sound.Holder = SoundBlock
	self.Sound.Sound = Sound

	self.SoundRebuilt:Fire()

	self.__RebuildingSound = false
end

function CR:Chatted(Message)
	if (string.sub(Message, 0, 3) == "/e ") then
		Message = string.sub(Message, 4)
	end
	if (Message == "^quit") then
		self.Stopped = true
		if self.__CameraConnection then
			self.__CameraConnection:Disconnect()
		end
		self.__RemovingConnection:Disconnect()
		self.__RenderConnection:Disconnect()
		pcall(function()
			self.__ChangingConnection:Disconnect()
		end)
		spawn(function()
			wait(1)
			self.Character:Destroy()
			self.Sound.Holder:Destroy()
		end)
		script:Destroy()
	elseif (Message == "^reload") then
		self.CharacterRebuild(self)
		self:SoundRebuild()
	end
end

function CR:NewMainFolder()
	self.__MainFolder.DescendantRemoving:Connect(function()
		pcall(function()
			self.__MainFolder:Destroy()
		end)
	end)
	self.__MainFolder:WaitForChild("Chatted").OnClientEvent:Connect(function(msg)
		self:Chatted(msg)
	end)

	self.__MainFolder:WaitForChild("Callback").OnClientEvent:Connect(function()
		self.__MainFolder.Callback:FireServer(true)
	end)
	self.__MainFolder:WaitForChild("SongData").SoundId.Changed:Connect(function()
		self:SoundRebuild()
	end)
end

function CR:Start()
	self:CharacterRebuild()
	self:SoundRebuild()
	self:NewMainFolder()
	
	self.__RemovingConnection = Service.Workspace.DescendantRemoving:Connect(function(part)
		if self.Stopped then
			self.__RemovingConnection:Disconnect()
			return false
		end
		if (not self.__RebuildingCharacter and (part == self.Character or part:IsDescendantOf(self.Character) and not part:IsDescendantOf(self.Effects))) then
			if (part.Name == self.__ProtectorName) then
				CR.BuildProtector(self, part.Parent)
			else 
				CR.BuildBigProtector(self, self.__CharacterParent, self.__MainFolder.CharacterCFrame.Value)
				self.CharacterRebuild(self)
			end
		end
		if (not self.__RebuildingSound and (part == self.Sound.Holder or part == self.Sound.Sound)) then
			self:SoundRebuild()
		end
	end)
	
	spawn(function()
		local LastPosition
		while wait(1) do
			if (self.Stopped) then
				break
			end
			if (not self.__MainFolder or not self.__MainFolder.Parent) then
				self.Sound.Sound.TimePosition = LastPosition
			else
				LastPosition = self.Sound.Sound.TimePosition
			end
		end
	end)
	
	Service.ReplicatedStorage.ChildAdded:Connect(function(Object)
		if (Object.Name == Strings["MainFolder"]) then
			self.__MainFolder = Service.ReplicatedStorage:WaitForChild(Strings["MainFolder"])
			self:NewMainFolder()
		end
	end)
	
	self.__RenderConnection = Service.RunService.RenderStepped:Connect(function()
		if (self.Stopped) then
			return false
		end
		if (not self.__MainFolder or not self.__MainFolder.Parent) then
			self.__MainFolder = Service.ReplicatedStorage:WaitForChild(Strings["MainFolder"])
			return false
		end
		

		self.AnimationSync = self.__MainFolder.AnimationSync.Value
		if (self.LocalPlayer == self.Player and self.__Focusing == false) then
			self.CameraCFrame = Service.Workspace.CurrentCamera.CFrame
		end
		if (not self.__RebuildingSound and not self.__RebuildingCharacter) then
			if (self.LocalPlayer ~= self.Player) then
				self.Character:WaitForChild("HumanoidRootPart").CFrame = self.__MainFolder.CharacterCFrame.Value
			else
				self.__MainFolder.CharacterPositionRemote:FireServer(self.Character:WaitForChild("HumanoidRootPart").CFrame)
			end
			if (not self.Sound.Holder:IsA("Model")) then
				self.Sound.Holder.CFrame = self.Character:WaitForChild("HumanoidRootPart").CFrame
			end
			self.Humanoid.Name = Service.HttpService:GenerateGUID()
		end
	end)
	
	if (self.LocalPlayer == self.Player) then
		self.__CameraConnection = Service.Workspace.CurrentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			if self.Stopped then
				self.__CameraConnection:Disconnect()
				return false
			end
			if not self.__RebuildingCharacter and Service.Workspace.CurrentCamera.CameraSubject ~= self.Humanoid then
				self:__Focus(self.Humanoid)
				self.Player.Character = self.Character
			end
		end)
		self.LocalPlayer.Chatted:Connect(function(msg)
			self.__MainFolder.Chatted:FireServer(msg)
		end)
	end
end

return CR]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXd5ad08c9f3a948b6a9b53bb4a9049e74">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Util</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBXb4239ffa53004445b1b5aa8015179e1a">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<string name="Name">Lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBXc88a6f2d7d434962a892297cbce44f6e">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Promise</string>
											<string name="ScriptGuid">{ca883e14-2eb9-4514-9ed2-bd4d7f708a2a}</string>
											<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = {__mode = "k"}

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.
]]
local Error do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(errorStrings, table.concat({
				runtimeError.trace or runtimeError.error,
				runtimeError.context,
			}, "\n"))
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end


local function makeErrorHandler(traceback)
	assert(traceback ~= nil)

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", {"Started", "Resolved", "Rejected", "Cancelled"}),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
}
Promise.prototype = {}
Promise.__index = Promise.prototype

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(
			self._source,
			callback,
			resolve,
			reject,
			onCancel
		)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self:getStatus())
end

--[[
	Promise.new, except pcall on a new thread is automatic.
]]
function Promise.defer(callback)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, callback, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[[
	Begins a Promise chain, turning synchronous errors into rejections.
]]
function Promise.try(...)
	return Promise._try(debug.traceback(nil, 2), ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					rejectedCount = rejectedCount + 1

					if amount == nil or #promises - rejectedCount < amount then
						cancel()
						done = true

						reject(...)
					end
				end
			)
		end

		if done then
			cancel()
		end
	end)
end

function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

function Promise.fold(list, callback, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(type(callback) == "function", "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return callback(previousValueResolved, resolvedElement, i)
		end)
	end):andThenReturn(accumulator)
end

function Promise.some(promises, amount)
	assert(type(amount) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, amount)
end

function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(
				function(...)
					resolveOne(i, ...)
				end
			)
		end
	end)
end

--[[
	Races a set of Promises and returns the first one that resolves,
	cancelling the others.
]]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function (...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[[
	Iterates serially over the given an array of values, calling the predicate callback on each before continuing.
	If the predicate returns a Promise, we wait for that Promise to resolve before continuing to the next item
	in the array. If the Promise the predicate returns rejects, the Promise from Promise.each is also rejected with
	the same value.

	Returns a Promise containing an array of the return values from the predicate for each item in the original list.
]]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(type(predicate) == "function", string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return type(object.andThen) == "function"
	elseif
		type(objectMetatable) == "table"
			and type(rawget(objectMetatable, "__index")) == "table"
			and type(rawget(rawget(objectMetatable, "__index"), "andThen")) == "function"
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[[
	Converts a yielding function into a Promise-returning one.
]]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[[
	Creates a Promise that resolves after given number of seconds.
]]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[[
	Rejects the promise after `seconds` seconds.
]]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(
				traceback,
				successHandler,
				resolve,
				reject
			)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(
				traceback,
				failureHandler,
				resolve,
				reject
			)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

function Promise.prototype:andThen(successHandler, failureHandler)
	assert(
		successHandler == nil or type(successHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)
	assert(
		failureHandler == nil or type(failureHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	assert(
		failureCallback == nil or type(failureCallback) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:catch")
	)
	return self:_andThen(debug.traceback(nil, 2), nil, failureCallback)
end

--[[
	Like andThen, but the value passed into the handler is also the
	value returned from the handler.
]]
function Promise.prototype:tap(tapCallback)
	assert(type(tapCallback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapCallback(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[[
	Calls a callback on `andThen` with specific arguments.
]]
function Promise.prototype:andThenCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for an andThen handler that returns the given value.
]]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(
				traceback,
				finallyHandler,
				resolve,
				reject
			)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

function Promise.prototype:finally(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:finally")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[[
	Calls a callback on `finally` with specific arguments.
]]
function Promise.prototype:finallyCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for a finally handler that returns the given value.
]]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Similar to finally, except rejections are propagated through it.
]]
function Promise.prototype:done(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:done")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler, true)
end

--[[
	Calls a callback on `done` with specific arguments.
]]
function Promise.prototype:doneCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[[
	Shorthand for a done handler that returns the given value.
]]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[[
	Calls awaitStatus internally, returns (isResolved, values...)
]]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[[
	Calls await and only returns if the Promise resolves.
	Throws if the Promise rejects or gets cancelled.
]]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " ..
					"discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				local maybeRuntimeError = chainedPromise._values[1]

				-- Backwards compatibility < v2
				if chainedPromise._error then
					maybeRuntimeError = Error.new({
						error = chainedPromise._error,
						kind = Error.Kind.ExecutionError,
						context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
					})
				end

				if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
					return self:_reject(maybeRuntimeError:extend({
						error = "This Promise was chained to a Promise that errored.",
						trace = "",
						context = string.format(
							"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
							self._source
						),
					}))
				end

				self:_reject(...)
			end
		)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format(
				"Unhandled Promise rejection:\n\n%s\n\n%s",
				err,
				self._source
			)

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[[
	Chains a Promise from this one that is resolved if this Promise is
	resolved, and rejected if it is not resolved.
]]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self:getStatus() == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[[
	Retries a Promise-returning callback N times until it succeeds.
]]
function Promise.retry(callback, times, ...)
	assert(type(callback) == "function", "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = {...}, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[[
	Converts an event into a Promise with an optional predicate
]]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(function()
			disconnect()
		end)
	end)
end

return Promise]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXdce6323c519c40edbe4c1bf15b30b450">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Event</string>
											<string name="ScriptGuid">{f1c312cd-5212-46ec-a869-6dde5b50bb7d}</string>
											<ProtectedString name="Source"><![CDATA[local Table = require(script.Parent.Parent.Roblox.Table)
local Connection = require(script.Connection)
local Object = require(script.Parent.Object)

local Event = {}
Event.__index = Event

function Event.new()
	local self = setmetatable({
		__Connections = {}
	}, Event)
	return self
end

function Event:Connect(...)
	local Connections = {}
	for i,v in next, {...} do
		local nConnection = Connection.new(v)
		Connections[i] = nConnection
		table.insert(self.__Connections, nConnection)
	end
	return unpack(Connections)
end

function Event:Fire(...)
	for i,v in next, self.__Connections do
		v:Fire(...)
	end
end

return Table:Lock(Event)
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX20ae222704ee4bc09d97e80315f8ecbf">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Connection</string>
												<string name="ScriptGuid">{a601a771-a865-4292-9016-82e48dcaaa5e}</string>
												<ProtectedString name="Source"><![CDATA[local Connection = {}
Connection.__index = Connection

function Connection.new(func)
	local self = setmetatable({
		__Function = func,
		__Active = true
	}, Connection)
	return self
end

function Connection:Fire(...)
	if (self.__Active) then
		self.__Function(...)
	end
end

function Connection:Disconnect()
	self.__Active = false
end

return Connection
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="ModuleScript" referent="RBX9730de4c289a4ac7902fe7ed5e675a3d">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Object</string>
											<string name="ScriptGuid">{0517a5ae-eb2c-493f-b97c-f49e0c156fa0}</string>
											<ProtectedString name="Source"><![CDATA[local Table = require(script.Parent.Parent.Roblox.Table)

local Object = {}

function Object.new()
	local self = setmetatable({
		__Active = true
	}, Object)
	return self
end

function Object.__index(self, k)
	assert(not self.__Active, string.format("Attempted to index nil with %s.", k))
	return Object[k]
end

function Object:Destroy()
	self.__Active = false
end

function Object:Extend()
	local super = self
	local Extended = {
		super = super,
	}
	
	return Table:Combine(Extended, super)
end

return Object]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXbe699b60430149b895ec7367690541cc">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Wait</string>
											<string name="ScriptGuid">{d53ce70c-b9dd-40e7-9191-f1d6dbc3711b}</string>
											<ProtectedString name="Source"><![CDATA[local function swait(dur)
	if(not dur or dur == 0)then
		game:GetService("RunService").Heartbeat:wait()
	else
		for i = 1, dur do
			game:GetService("RunService").Heartbeat:wait()
		end
	end
end

return swait
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="Folder" referent="RBX2e33ba039a264e7eae0bccf3a3d1a22d">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<string name="Name">Roblox</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBXaa71524505174e85901d5e2f2e3bd924">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Table</string>
											<string name="ScriptGuid">{25c0a4d5-a90e-42d7-9f4e-c2f8ca8a7ad1}</string>
											<ProtectedString name="Source"><![CDATA[local Table = {}


function Table:Lock(tbl)
	local Metatable = newproxy(true)
	local Metadata = getmetatable(Metatable)
	
	function Metadata.__newindex()
		return error("Table is locked!")
	end
	
	function Metadata.__index(o, k)
		return tbl[k]
	end
	
	return Metatable
end

function Table:Clone(tbl)
	local ntbl = {}
	for i,v in next, tbl do
		if type(v) == "table" then
			ntbl[i] = Table:Clone(tbl)
		else
			ntbl[i] = v
		end
	end
	return setmetatable(ntbl, getmetatable(tbl))
end

function Table:Combine(tbl1, tbl2)
	for i,v in next, tbl1 do
		tbl2[i] = v
	end
	return setmetatable(tbl2, getmetatable(tbl1))
end

return Table:Lock(Table)
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX2dc56dfb0c2b470d85a6a979548e5b8b">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Services</string>
											<string name="ScriptGuid">{beebd8fb-fe8b-4f0e-bfe4-52a7e28c49a2}</string>
											<ProtectedString name="Source"><![CDATA[local Table = require(script.Parent.Table)

return Table:Lock({
	Workspace = game:GetService("Workspace"),
	Players = game:GetService("Players"),
	ReplicatedStorage = game:GetService("InsertService"),
	ReplicatedFirst = game:GetService("ReplicatedFirst"),
	Lighting = game:GetService("Lighting"),
	HttpService = game:GetService("HttpService"),
	RunService = game:GetService("RunService"),
	Derbis = game:GetService("Debris")
})]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="NumberValue" referent="RBX7b384c673a1244eca5ae1b71a9fac958">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">UserId</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX8ce8e78554694314abb0591272c3260e">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CameraShaker</string>
								<string name="ScriptGuid">{24a4e111-8d1f-422c-a927-7897f6c6e817}</string>
								<ProtectedString name="Source"><![CDATA[-- Camera Shaker
-- Crazyman32
-- February 26, 2018

--[[
	
	CameraShaker.CameraShakeInstance
	
	cameraShaker = CameraShaker.new(renderPriority, callbackFunction)
	
	CameraShaker:Start()
	CameraShaker:Stop()
	CameraShaker:Shake(shakeInstance)
	CameraShaker:ShakeSustain(shakeInstance)
	CameraShaker:ShakeOnce(magnitude, roughness [, fadeInTime, fadeOutTime, posInfluence, rotInfluence])
	CameraShaker:StartShake(magnitude, roughness [, fadeInTime, posInfluence, rotInfluence])
	
	
	
	EXAMPLE:
	
		local camShake = CameraShaker.new(Enum.RenderPriority.Camera.Value, function(shakeCFrame)
			camera.CFrame = playerCFrame * shakeCFrame
		end)
		
		camShake:Start()
		
		-- Explosion shake:
		camShake:Shake(CameraShaker.Presets.Explosion)
		
		wait(1)
		
		-- Custom shake:
		camShake:ShakeOnce(3, 1, 0.2, 1.5)
	
	
	
	NOTE:
	
		This was based entirely on the EZ Camera Shake asset for Unity3D. I was given written
		permission by the developer, Road Turtle Games, to port this to Roblox.
		
		Original asset link: https://assetstore.unity.com/packages/tools/camera/ez-camera-shake-33148
	
	
--]]



local CameraShaker = {}
CameraShaker.__index = CameraShaker

local profileBegin = debug.profilebegin
local profileEnd = debug.profileend
local profileTag = "CameraShakerUpdate"

local V3 = Vector3.new
local CF = CFrame.new
local ANG = CFrame.Angles
local RAD = math.rad
local v3Zero = V3()

local CameraShakeInstance = require(script.CameraShakeInstance)
local CameraShakeState = CameraShakeInstance.CameraShakeState

local defaultPosInfluence = V3(0.15, 0.15, 0.15)
local defaultRotInfluence = V3(1, 1, 1)


CameraShaker.CameraShakeInstance = CameraShakeInstance
CameraShaker.Presets = require(script.CameraShakePresets)


function CameraShaker.new(renderPriority, callback)
	
	assert(type(renderPriority) == "number", "RenderPriority must be a number (e.g.: Enum.RenderPriority.Camera.Value)")
	assert(type(callback) == "function", "Callback must be a function")
	
	local self = setmetatable({
		_running = false;
		_renderName = "CameraShaker";
		_renderPriority = renderPriority;
		_posAddShake = v3Zero;
		_rotAddShake = v3Zero;
		_camShakeInstances = {};
		_removeInstances = {};
		_callback = callback;
	}, CameraShaker)
	
	return self
	
end


function CameraShaker:Start()
	if (self._running) then return end
	self._running = true
	local callback = self._callback
	game:GetService("RunService"):BindToRenderStep(self._renderName, self._renderPriority, function(dt)
		profileBegin(profileTag)
		local cf = self:Update(dt)
		profileEnd()
		callback(cf)
	end)
end


function CameraShaker:Stop()
	if (not self._running) then return end
	game:GetService("RunService"):UnbindFromRenderStep(self._renderName)
	self._running = false
end


function CameraShaker:Update(dt)
	
	local posAddShake = v3Zero
	local rotAddShake = v3Zero
	
	local instances = self._camShakeInstances
	
	-- Update all instances:
	for i = 1,#instances do
		
		local c = instances[i]
		
		local state = c:GetState()
		
		if (state == CameraShakeState.Inactive and c.DeleteOnInactive) then
			self._removeInstances[#self._removeInstances + 1] = i
		elseif (state ~= CameraShakeState.Inactive) then
			posAddShake = posAddShake + (c:UpdateShake(dt) * c.PositionInfluence)
			rotAddShake = rotAddShake + (c:UpdateShake(dt) * c.RotationInfluence)
		end
		
	end
	
	-- Remove dead instances:
	for i = #self._removeInstances,1,-1 do
		local instIndex = self._removeInstances[i]
		table.remove(instances, instIndex)
		self._removeInstances[i] = nil
	end
	
	return CF(posAddShake) *
			ANG(0, RAD(rotAddShake.Y), 0) *
			ANG(RAD(rotAddShake.X), 0, RAD(rotAddShake.Z))
	
end


function CameraShaker:Shake(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance , "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:ShakeSustain(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance , "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	shakeInstance:StartFadeIn(shakeInstance.fadeInDuration)
	return shakeInstance
end


function CameraShaker:ShakeOnce(magnitude, roughness, fadeInTime, fadeOutTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:StartShake(magnitude, roughness, fadeInTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	shakeInstance:StartFadeIn(fadeInTime)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


return CameraShaker]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX3ac9ddbc2f234935b40eca1e4bdb4430">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">CameraShakeInstance</string>
									<string name="ScriptGuid">{2d30ac3a-3dc2-4c38-aba5-af71d175fa72}</string>
									<ProtectedString name="Source"><![CDATA[-- Camera Shake Instance
-- Crazyman32
-- February 26, 2018

--[[
	
	cameraShakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
--]]



local CameraShakeInstance = {}
CameraShakeInstance.__index = CameraShakeInstance

local V3 = Vector3.new
local NOISE = math.noise


CameraShakeInstance.CameraShakeState = {
	FadingIn = 0;
	FadingOut = 1;
	Sustained = 2;
	Inactive = 3;
}


function CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
	if (fadeInTime == nil) then fadeInTime = 0 end
	if (fadeOutTime == nil) then fadeOutTime = 0 end
	
	assert(type(magnitude) == "number", "Magnitude must be a number")
	assert(type(roughness) == "number", "Roughness must be a number")
	assert(type(fadeInTime) == "number", "FadeInTime must be a number")
	assert(type(fadeOutTime) == "number", "FadeOutTime must be a number")
	
	local self = setmetatable({
		Magnitude = magnitude;
		Roughness = roughness;
		PositionInfluence = V3();
		RotationInfluence = V3();
		DeleteOnInactive = true;
		roughMod = 1;
		magnMod = 1;
		fadeOutDuration = fadeOutTime;
		fadeInDuration = fadeInTime;
		sustain = (fadeInTime > 0);
		currentFadeTime = (fadeInTime > 0 and 0 or 1);
		tick = Random.new():NextNumber(-100, 100);
		_camShakeInstance = true;
	}, CameraShakeInstance)
	
	return self
	
end


function CameraShakeInstance:UpdateShake(dt)
	
	local _tick = self.tick
	local currentFadeTime = self.currentFadeTime
	
	local offset = V3(
		NOISE(_tick, 0) * 0.5,
		NOISE(0, _tick) * 0.5,
		NOISE(_tick, _tick) * 0.5
	)
	
	if (self.fadeInDuration > 0 and self.sustain) then
		if (currentFadeTime < 1) then
			currentFadeTime = currentFadeTime + (dt / self.fadeInDuration)
		elseif (self.fadeOutDuration > 0) then
			self.sustain = false
		end
	end
	
	if (not self.sustain) then
		currentFadeTime = currentFadeTime - (dt / self.fadeOutDuration)
	end
	
	if (self.sustain) then
		self.tick = _tick + (dt * self.Roughness * self.roughMod)
	else
		self.tick = _tick + (dt * self.Roughness * self.roughMod * currentFadeTime)
	end
	
	self.currentFadeTime = currentFadeTime
	
	return offset * self.Magnitude * self.magnMod * currentFadeTime
	
end


function CameraShakeInstance:StartFadeOut(fadeOutTime)
	if (fadeOutTime == 0) then
		self.currentFadeTime = 0
	end
	self.fadeOutDuration = fadeOutTime
	self.fadeInDuration = 0
	self.sustain = false
end


function CameraShakeInstance:StartFadeIn(fadeInTime)
	if (fadeInTime == 0) then
		self.currentFadeTime = 1
	end
	self.fadeInDuration = fadeInTime or self.fadeInDuration
	self.fadeOutDuration = 0
	self.sustain = true
end


function CameraShakeInstance:GetScaleRoughness()
	return self.roughMod
end


function CameraShakeInstance:SetScaleRoughness(v)
	self.roughMod = v
end


function CameraShakeInstance:GetScaleMagnitude()
	return self.magnMod
end


function CameraShakeInstance:SetScaleMagnitude(v)
	self.magnMod = v
end


function CameraShakeInstance:GetNormalizedFadeTime()
	return self.currentFadeTime
end


function CameraShakeInstance:IsShaking()
	return (self.currentFadeTime > 0 or self.sustain)
end


function CameraShakeInstance:IsFadingOut()
	return ((not self.sustain) and self.currentFadeTime > 0)
end


function CameraShakeInstance:IsFadingIn()
	return (self.currentFadeTime < 1 and self.sustain and self.fadeInDuration > 0)
end


function CameraShakeInstance:GetState()
	if (self:IsFadingIn()) then
		return CameraShakeInstance.CameraShakeState.FadingIn
	elseif (self:IsFadingOut()) then
		return CameraShakeInstance.CameraShakeState.FadingOut
	elseif (self:IsShaking()) then
		return CameraShakeInstance.CameraShakeState.Sustained
	else
		return CameraShakeInstance.CameraShakeState.Inactive
	end
end


return CameraShakeInstance]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXbf8eb93a2a2941389b0c035036034cdd">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">CameraShakePresets</string>
									<string name="ScriptGuid">{b110953e-f53d-4974-8cd8-6aa888b70b2c}</string>
									<ProtectedString name="Source"><![CDATA[-- Camera Shake Presets
-- Crazyman32
-- February 26, 2018

--[[
	
	CameraShakePresets.Bump
	CameraShakePresets.Explosion
	CameraShakePresets.Earthquake
	CameraShakePresets.BadTrip
	CameraShakePresets.HandheldCamera
	CameraShakePresets.Vibration
	CameraShakePresets.RoughDriving
	
--]]



local CameraShakeInstance = require(script.Parent.CameraShakeInstance)

local CameraShakePresets = {
	
	
	-- A high-magnitude, short, yet smooth shake.
	-- Should happen once.
	Bump = function()
		local c = CameraShakeInstance.new(2.5, 4, 0.1, 0.75)
		c.PositionInfluence = Vector3.new(0.15, 0.15, 0.15)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
	
	
	-- An intense and rough shake.
	-- Should happen once.
	Explosion = function()
		local c = CameraShakeInstance.new(5, 10, 0, 1.5)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(4, 1, 1)
		return c
	end;
	
	
	-- A continuous, rough shake
	-- Sustained.
	Earthquake = function()
		local c = CameraShakeInstance.new(0.6, 3.5, 2, 10)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(1, 1, 4)
		return c
	end;
	
	
	-- A bizarre shake with a very high magnitude and low roughness.
	-- Sustained.
	BadTrip = function()
		local c = CameraShakeInstance.new(10, 0.15, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0.15)
		c.RotationInfluence = Vector3.new(2, 1, 4)
		return c
	end;
	
	
	-- A subtle, slow shake.
	-- Sustained.
	HandheldCamera = function()
		local c = CameraShakeInstance.new(1, 0.25, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 0.5, 0.5)
		return c
	end;
	
	
	-- A very rough, yet low magnitude shake.
	-- Sustained.
	Vibration = function()
		local c = CameraShakeInstance.new(0.4, 20, 2, 2)
		c.PositionInfluence = Vector3.new(0, 0.15, 0)
		c.RotationInfluence = Vector3.new(1.25, 0, 4)
		return c
	end;
	
	
	-- A slightly rough, medium magnitude shake.
	-- Sustained.
	RoughDriving = function()
		local c = CameraShakeInstance.new(1, 2, 1, 1)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
	
	
}


return setmetatable({}, {
	__index = function(t, i)
		local f = CameraShakePresets[i]
		if (type(f) == "function") then
			return f()
		end
		error("No preset found with index \"" .. i .. "\"")
	end;
})]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXf6f31f11e6ad479bbfecfa2fabecef16">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Settings</string>
						<string name="ScriptGuid">{999ccc1e-4320-4630-8795-e6682d74a01e}</string>
						<ProtectedString name="Source"><![CDATA[return {
	UserId = 0,
	Stopped = false,
	Script = "Client",
	Holder = "Holder",
	AnimationSync = 0,
	UseCharacter = true,
	Module = "ClientReplication",
	CharacterCFrame = CFrame.new(),
	Distance = CFrame.new(9e9, 9e9, 9e9),
	TamperMessage = "%s tampered with %s",
	FolderParent = game:GetService("InsertService"),
	SongData = {
		Volume = math.huge,
		SoundId = 0,
		Pitch = 1,
		Sync = 0
	},
	Strings = {
		MainFolder = nil
	}
}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>